// Generated by CoffeeScript 1.6.3
(function() {
  var Shaders, Volumetric;

  Volumetric = (function() {
    Volumetric.prototype._loadShader = function(gl, source, type) {
      var compiled, lastError, shader;
      shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
        lastError = gl.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    Volumetric.prototype._createProgram = function(gl, vertexShader, fragmentShader) {
      var linked, program;
      vertexShader = this._loadShader(gl, vertexShader, gl.VERTEX_SHADER);
      fragmentShader = this._loadShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      gl.linkProgram(program);
      linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      gl.useProgram(program);
      program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
      gl.enableVertexAttribArray(program.vertexPositionAttribute);
      program.vertexColorAttribute = gl.getAttribLocation(program, "aVertexColor");
      gl.enableVertexAttribArray(program.vertexColorAttribute);
      program.uPMatrix = gl.getUniformLocation(program, "uPMatrix");
      program.uMVMatrix = gl.getUniformLocation(program, "uMVMatrix");
      return program;
    };

    Volumetric.prototype._initFrameBuffer = function(gl, width, height) {
      var frameBuffer;
      frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      frameBuffer.depthbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, frameBuffer.depthbuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, frameBuffer.depthbuffer);
      frameBuffer.tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, frameBuffer.tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4 * width * height));
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, frameBuffer.tex, 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
        return null;
      }
      return frameBuffer;
    };

    Volumetric.prototype._initCubeBuffer = function(gl) {
      var colors, cube, vertexIndices, vertices;
      cube = {};
      cube.vertexPositionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cube.vertexPositionBuffer);
      vertices = [0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      cube.vertexPositionBuffer.itemSize = 3;
      cube.vertexPositionBuffer.numItems = 24;
      cube.vertexColorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cube.vertexColorBuffer);
      colors = [0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
      cube.vertexColorBuffer.itemSize = 4;
      cube.vertexColorBuffer.numItems = 24;
      cube.vertexIndexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cube.vertexIndexBuffer);
      vertexIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertexIndices), gl.STATIC_DRAW);
      cube.vertexIndexBuffer.itemSize = 1;
      cube.vertexIndexBuffer.numItems = 36;
      return cube;
    };

    Volumetric.prototype._setMatrices = function(program) {
      this.gl.uniformMatrix4fv(program.uPMatrix, false, this.pMatrix);
      return this.gl.uniformMatrix4fv(program.uMVMatrix, false, this.mvMatrix);
    };

    Volumetric.prototype._setRaycastUniforms = function(gl) {
      this.uMinimum = gl.getUniformLocation(this.programs.raycast, "uMinimum");
      this.uMaximum = gl.getUniformLocation(this.programs.raycast, "uMaximum");
      this.uRange = gl.getUniformLocation(this.programs.raycast, "uRange");
      this.uTileWidth = gl.getUniformLocation(this.programs.raycast, "uTileWidth");
      this.uTileHeight = gl.getUniformLocation(this.programs.raycast, "uTileHeight");
      this.uDimension = gl.getUniformLocation(this.programs.raycast, "uDimension");
      this.uBackCoord = gl.getUniformLocation(this.programs.raycast, "uBackCoord");
      this.uVolData = gl.getUniformLocation(this.programs.raycast, "uVolData");
      this.uTiles = gl.getUniformLocation(this.programs.raycast, "uTiles");
      this.uOpacity = gl.getUniformLocation(this.programs.raycast, "uOpacity");
      return this.uLighting = gl.getUniformLocation(this.programs.raycast, "uLight");
    };

    Volumetric.prototype._toRadians = function(deg) {
      return deg * 0.017453292519943295;
    };

    Volumetric.prototype._toPower2 = function(v) {
      v--;
      v |= v >> 1;
      v |= v >> 2;
      v |= v >> 4;
      v |= v >> 8;
      v |= v >> 16;
      v++;
      return v;
    };

    Volumetric.prototype._setupMouseControls = function() {
      var _this = this;
      this.drag = false;
      this.xOldOffset = null;
      this.yOldOffset = null;
      this.canvas.onmousedown = function(e) {
        _this.drag = true;
        _this.xOldOffset = e.clientX;
        return _this.yOldOffset = e.clientY;
      };
      this.canvas.onmouseup = function(e) {
        return _this.drag = false;
      };
      this.canvas.onmousemove = function(e) {
        var deltaX, deltaY, rotationMatrix, x, y;
        if (!_this.drag) {
          return;
        }
        x = e.clientX;
        y = e.clientY;
        deltaX = x - _this.xOldOffset;
        deltaY = y - _this.yOldOffset;
        rotationMatrix = mat4.create();
        mat4.identity(rotationMatrix);
        mat4.rotateY(rotationMatrix, rotationMatrix, _this._toRadians(deltaX / 4));
        mat4.rotateX(rotationMatrix, rotationMatrix, _this._toRadians(deltaY / 4));
        mat4.multiply(_this.rotationMatrix, rotationMatrix, _this.rotationMatrix);
        _this.xOldOffset = x;
        _this.yOldOffset = y;
        return _this.draw();
      };
      this.canvas.onmouseout = function(e) {
        return _this.drag = false;
      };
      return this.canvas.onmouseover = function(e) {
        return _this.drag = false;
      };
    };

    function Volumetric(el, dimension) {
      var ext, gl, height, name, shaders, width, _i, _len, _ref;
      this.el = el;
      this.viewportWidth = this.viewportHeight = dimension;
      this.programs = {};
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('width', this.viewportWidth);
      this.canvas.setAttribute('height', this.viewportHeight);
      this.canvas.setAttribute('class', 'volumetric');
      this.el.appendChild(this.canvas);
      _ref = ['webgl', 'experimental-webgl'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        gl = this.canvas.getContext(name);
        width = this.canvas.width;
        height = this.canvas.height;
        if (gl != null) {
          break;
        }
      }
      if (!gl) {
        return null;
      }
      gl.viewport(0, 0, width, height);
      this.gl = gl;
      ext = gl.getExtension('OES_texture_float');
      if (!ext) {
        return null;
      }
      shaders = this.constructor.Shaders;
      this.programs["back"] = this._createProgram(gl, shaders.vertex, shaders.fragment);
      this.programs["raycast"] = this._createProgram(gl, shaders.raycastVertex, shaders.raycastFragment("70.0"));
      this._setRaycastUniforms(this.gl);
      this.frameBuffer = this._initFrameBuffer(gl, this.viewportWidth, this.viewportHeight);
      this.cubeBuffer = this._initCubeBuffer(gl);
      this.zoom = 2.0;
      this.pMatrix = mat4.create();
      this.mvMatrix = mat4.create();
      this.rotationMatrix = mat4.create();
      mat4.perspective(this.pMatrix, 45.0, 1.0, 0.1, 100.0);
      mat4.identity(this.rotationMatrix);
      this.setOpacity(2.0);
      this.setLighting(0.3);
      this._setupMouseControls();
      this.hasTexture = false;
    }

    Volumetric.prototype.setExtent = function(minimum, maximum) {
      this.minimum = minimum;
      this.maximum = maximum;
      this.gl.useProgram(this.programs.raycast);
      this.gl.uniform1f(this.uMinimum, this.minimum);
      this.gl.uniform1f(this.uMaximum, this.maximum);
      this.gl.uniform1f(this.uRange, this.maximum - this.minimum);
      return this.draw();
    };

    Volumetric.prototype.setSteps = function(steps) {
      var gl, program, shader, shaders, _i, _len, _ref;
      gl = this.gl;
      program = this.programs.raycast;
      _ref = gl.getAttachedShaders(program);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shader = _ref[_i];
        gl.detachShader(program, shader);
        gl.deleteShader(shader);
      }
      gl.deleteProgram(program);
      shaders = this.constructor.Shaders;
      this.programs["raycast"] = this._createProgram(gl, shaders.raycastVertex, shaders.raycastFragment("" + steps + ".0"));
      this._setRaycastUniforms(gl);
      gl.useProgram(this.programs.raycast);
      gl.activeTexture(gl.TEXTURE0);
      gl.uniform1f(this.uTiles, this.depth);
      gl.uniform1f(this.uTileWidth, this.width);
      gl.uniform1f(this.uTileHeight, this.height);
      gl.uniform1f(this.uDimension, this.dimension);
      gl.uniform1f(this.uMinimum, this.minimum);
      gl.uniform1f(this.uMaximum, this.maximum);
      gl.uniform1f(this.uRange, this.maximum - this.minimum);
      gl.uniform1f(this.uOpacity, this.opacity);
      gl.uniform1f(this.uLighting, this.lighting);
      return this.draw();
    };

    Volumetric.prototype.setOpacity = function(opacity) {
      this.opacity = opacity;
      this.gl.useProgram(this.programs.raycast);
      this.gl.uniform1f(this.uOpacity, opacity);
      return this.draw();
    };

    Volumetric.prototype.setLighting = function(lighting) {
      this.lighting = lighting;
      this.gl.useProgram(this.programs.raycast);
      this.gl.uniform1f(this.uLighting, lighting);
      return this.draw();
    };

    Volumetric.prototype.setTexture2 = function(arr, width, height, depth) {};

    Volumetric.prototype.setTexture = function(arr, width, height, depth) {
      var dimension, length, pixels;
      length = arr.length;
      dimension = Math.sqrt(length);
      dimension = this._toPower2(dimension);
      this.gl.uniform1f(this.uTiles, depth);
      while (length--) {
        arr[length] = isNaN(arr[length]) ? 0 : arr[length];
      }
      pixels = new arr.constructor(dimension * dimension);
      pixels.set(arr, 0);
      if (!this.hasTexture) {
        this.gl.uniform1f(this.uTileWidth, width);
        this.gl.uniform1f(this.uTileHeight, height);
        this.gl.uniform1f(this.uDimension, dimension);
        this.texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      }
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, dimension, dimension, 0, this.gl.LUMINANCE, this.gl.FLOAT, pixels);
      this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      this.hasTexture = true;
      this.width = width;
      this.height = height;
      this.depth = depth;
      return this.dimension = dimension;
    };

    Volumetric.prototype._drawCube = function(program) {
      this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
      mat4.identity(this.mvMatrix);
      mat4.translate(this.mvMatrix, this.mvMatrix, [0.0, 0.0, -this.zoom]);
      mat4.multiply(this.mvMatrix, this.mvMatrix, this.rotationMatrix);
      mat4.translate(this.mvMatrix, this.mvMatrix, [-0.5, -0.5, -0.5]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cubeBuffer.vertexPositionBuffer);
      this.gl.vertexAttribPointer(program.vertexPositionAttribute, this.cubeBuffer.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.cubeBuffer.vertexColorBuffer);
      this.gl.vertexAttribPointer(program.vertexColorAttribute, this.cubeBuffer.vertexColorBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.cubeBuffer.vertexIndexBuffer);
      this._setMatrices(program);
      return this.gl.drawElements(this.gl.TRIANGLES, this.cubeBuffer.vertexIndexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
    };

    Volumetric.prototype.draw = function() {
      this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.frameBuffer);
      this.gl.useProgram(this.programs.back);
      this.gl.clearDepth(-50.0);
      this.gl.depthFunc(this.gl.GEQUAL);
      this._drawCube(this.programs.back);
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      this.gl.useProgram(this.programs.raycast);
      this.gl.clearDepth(50.0);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.frameBuffer.tex);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
      this.gl.uniform1i(this.uBackCoord, 0);
      this.gl.uniform1i(this.uVolData, 1);
      return this._drawCube(this.programs.raycast);
    };

    return Volumetric;

  })();

  if (this.astro == null) {
    this.astro = {};
  }

  this.astro.Volumetric = Volumetric;

  this.astro.Volumetric.version = '0.2.0';

  Shaders = {
    vertex: ["precision mediump float;", "attribute vec3 aVertexPosition;", "attribute vec4 aVertexColor;", "uniform mat4 uMVMatrix;", "uniform mat4 uPMatrix;", "varying vec4 backColor;", "void main() {", "vec4 position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);", "backColor = aVertexColor;", "gl_Position = position;", "}"].join("\n"),
    fragment: ["precision mediump float;", "varying vec4 backColor;", "void main() {", "gl_FragColor = backColor;", "}"].join("\n"),
    raycastVertex: ["precision mediump float;", "attribute vec3 aVertexPosition;", "attribute vec4 aVertexColor;", "uniform mat4 uMVMatrix;", "uniform mat4 uPMatrix;", "varying vec4 frontColor;", "varying vec4 position;", "void main() {", "position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);", "frontColor = aVertexColor;", "gl_Position = position;", "}"].join("\n"),
    raycastFragment: function(STEPS) {
      return ["precision highp float;", "varying vec4 frontColor;", "varying vec4 position;", "uniform sampler2D uBackCoord;", "uniform sampler2D uVolData;", "uniform float uMinimum;", "uniform float uMaximum;", "uniform float uRange;", "uniform float uTiles;", "uniform float uTileWidth;", "uniform float uTileHeight;", "uniform float uDimension;", "uniform float uOpacity;", "uniform float uLight;", "const float MAXSTEPS = " + STEPS + ";", "float getTextureValue(vec3 volumePosition) {", "vec2 texturePosition1;", "vec2 texturePosition2;", "float zp1 = floor(volumePosition.z * uTiles);", "float zp2 = zp1 + 1.0;", "float xp = floor(uTileWidth * volumePosition.x);", "float yp = floor(uTileHeight * volumePosition.y);", "float index1 = zp1 * uTileWidth * uTileHeight + yp * uTileWidth + xp;", "float index2 = zp2 * uTileWidth * uTileHeight + yp * uTileWidth + xp;", "float xt1 = mod(index1, uDimension);", "float yt1 = floor(index1 / uDimension);", "float xt2 = mod(index2, uDimension);", "float yt2 = floor(index2 / uDimension);", "texturePosition1.x = xt1 / uDimension;", "texturePosition1.y = yt1 / uDimension;", "texturePosition2.x = xt2 / uDimension;", "texturePosition2.y = yt2 / uDimension;", "float value1 = texture2D(uVolData, texturePosition1).x;", "float value2 = texture2D(uVolData, texturePosition2).x;", "value1 = (value1 - uMinimum) / uRange;", "value2 = (value2 - uMinimum) / uRange;", "return mix( value1, value2, (volumePosition.z * uTiles) - zp1 );", "}", "void main() {", "vec2 textureCoord = position.xy / position.w;", "textureCoord.x = 0.5 * textureCoord.x + 0.5;", "textureCoord.y = 0.5 * textureCoord.y + 0.5;", "vec4 backColor = texture2D(uBackCoord, textureCoord);", "vec3 color = backColor.rgb - frontColor.rgb;", "vec4 vpos = frontColor;", "vec3 step = color / MAXSTEPS;", "vec4 accum = vec4(0.0, 0.0, 0.0, 0.0);", "vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);", "vec4 value = vec4(0.0, 0.0, 0.0, 0.0);", "vec2 transferPosition;", "for(float i = 0.0; i < MAXSTEPS; i += 1.0) {", "transferPosition.x = getTextureValue(vpos.xyz);", "transferPosition.y = 0.5;", "value = vec4(transferPosition.x);", "sample.a = value.a * uOpacity * (1.0 / MAXSTEPS);", "sample.rgb = value.rgb * sample.a * uLight;", "accum.rgb += (1.0 - accum.a) * sample.rgb;", "accum.a += sample.a;", "vpos.xyz += step;", "if (vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || accum.a >= 1.0)", "break;", "}", "gl_FragColor = accum;", "}"].join("\n");
    }
  };

  this.astro.Volumetric.Shaders = Shaders;

}).call(this);
